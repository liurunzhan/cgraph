#include "template_data.ct"

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, check)(const TYPE cthis) {
  return CGRAPH_TRUE;
}

/**
 * Fowlerï¼ŒLandon Curt Noll and Phong Vo in 1991) :
 * begin_of_algorithm
 * hash = offset_basis for byte_of_data in data
 * begin
 *   hash = hash ^ byte_of_data
 *   hash = hash * fnv_prime
 * end
 * return hash
 * end_of_algorithm
 *
 * where :
 * 32-bit offset_basis : 2166136261
 * 32-bit fnv_prime    : 16777619 = 2^24 + 2^8 + 0x93
 * 64-bit offset_basis : 14695981039346656037
 * 64-bit fnv_prime    : 1099511628211 = 2^40 + 2^8 + 0xb3
 */
cgraph_size_t FUNCTION(NAME, hash)(const TYPE cthis) {
#if defined(TYPE_BOOL)
  cgraph_size_t hash = ((cthis == CGRAPH_FALSE) ? 0 : 1);
#elif defined(TYPE_INT)
  cgraph_size_t hash = 2166136261UL;
  char *tmp = (char *)&cthis;
  cgraph_size_t i;
  for (i = 0; i < sizeof(TYPE); i++) {
    hash = (hash ^ tmp[i]) * 16777619UL;
  }
#elif defined(TYPE_INT32)
  cgraph_size_t hash = 0;
  hash = ((cthis >> 16) ^ cthis) * 0x45d9f3b;
  hash = ((hash >> 16) ^ hash) * 0x45d9f3b;
  hash = (hash >> 16) ^ hash;
#else
  cgraph_size_t hash = cthis;
#endif

  return hash;
}

cgraph_int_t FUNCTION(NAME, printf)(const TYPE cthis) {
#ifdef TYPE_BOOL
  return fprintf(stdout, "%s", FUNCTION(NAME, bool2str)(cthis));
#else
  return __extension__ fprintf(stdout, OUT_FORMAT, cthis);
#endif
}

cgraph_int_t FUNCTION(NAME, fprintf)(FILE *fp, const TYPE cthis) {
#ifdef TYPE_BOOL
  return fprintf(fp, "%s", FUNCTION(NAME, bool2str)(cthis));
#else
  return __extension__ fprintf(fp, OUT_FORMAT, cthis);
#endif
}

cgraph_int_t FUNCTION(NAME, snprintf)(cgraph_char_t *buffer,
                                      const cgraph_size_t size,
                                      const TYPE cthis) {
#ifdef TYPE_BOOL
  return cgraph_file_snprintf(buffer, size, "%s",
                              FUNCTION(NAME, bool2str)(cthis));
#else
  return cgraph_file_snprintf(buffer, size, OUT_FORMAT, cthis);
#endif
}

CGRAPH_INLINE cgraph_int_t FUNCTION(NAME, signbit)(const TYPE x) {
  return x | (x >> (BITS - 1));
}

CGRAPH_INLINE TYPE FUNCTION(NAME, zero)(void) {
#ifdef TYPE_BOOL
  return CGRAPH_FALSE;
#else
  return 0;
#endif
}

CGRAPH_INLINE TYPE FUNCTION(NAME, one)(void) {
#ifdef TYPE_BOOL
  return CGRAPH_TRUE;
#else
  return 1;
#endif
}

CGRAPH_INLINE TYPE FUNCTION(NAME, ones)(void) {
#ifdef TYPE_BOOL
  return CGRAPH_TRUE;
#else
  return MIN;
#endif
}

TYPE FUNCTION(NAME, random)(void) {
  TYPE res;
  return res;
}

TYPE *FUNCTION(NAME, initargs)(TYPE *cthis, const cgraph_size_t size,
                               const TYPE first, ...) {
  if ((NULL != cthis) && (0 < size)) {
    cgraph_size_t i = 1;
    va_list args;
    va_start(args, first);
    cthis[0] = (TYPE)first;
    for (i = 1; i < size; i++) {
      cthis[i] = (TYPE)va_arg(args, ARG);
    }
    va_end(args);
  }

  return cthis;
}

TYPE FUNCTION(NAME, gcd)(const TYPE x, const TYPE y) {
  TYPE _x = x, _y = y;
  while (_x != _y) {
    if (_x < _y) {
      SWAP(_x, _y);
    }
    _x -= _y;
  }

  return _x;
}

TYPE FUNCTION(NAME, lcm)(const TYPE x, const TYPE y) {
  return x / FUNCTION(NAME, gcd)(x, y) * y;
}

CGRAPH_INLINE TYPE FUNCTION(NAME, and)(const TYPE x, const TYPE y) {
  return CGRAPH_AND(x, y);
}

CGRAPH_INLINE TYPE FUNCTION(NAME, or)(const TYPE x, const TYPE y) {
  return CGRAPH_OR(x, y);
}

CGRAPH_INLINE TYPE FUNCTION(NAME, not )(const TYPE x) { return CGRAPH_NOT(x); }

CGRAPH_INLINE TYPE FUNCTION(NAME, xor)(const TYPE x, const TYPE y) {
  return CGRAPH_XOR(x, y);
}

CGRAPH_INLINE TYPE FUNCTION(NAME, xnor)(const TYPE x, const TYPE y) {
  return CGRAPH_XNOR(x, y);
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, bit)(const UTYPE x,
                                        const cgraph_size_t position) {
  return (BITS < position) ? CGRAPH_BIT(x, position) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, set)(const UTYPE x,
                                        const cgraph_size_t position) {
  return (BITS < position) ? CGRAPH_BSET(x, position) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, clr)(const UTYPE x,
                                        const cgraph_size_t position) {
  return (BITS < position) ? CGRAPH_BCLR(x, position) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, bits)(const UTYPE x,
                                         const cgraph_size_t from,
                                         const cgraph_size_t to) {
  return (to > from) ? CGRAPH_BITS(x, from, to) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, sets)(const UTYPE x,
                                         const cgraph_size_t from,
                                         const cgraph_size_t to) {
  return (to > from) ? CGRAPH_BSETS(x, from, to) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, clrs)(const UTYPE x,
                                         const cgraph_size_t from,
                                         const cgraph_size_t to) {
  return (to > from) ? CGRAPH_BCLRS(x, from, to) : 0;
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, iszero)(const TYPE x) {
#ifdef TYPE_BOOL
  return CGRAPH_TEST((CGRAPH_FALSE == x));
#else
  return CGRAPH_TEST((0 == x));
#endif
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isone)(const TYPE x) {
#ifdef TYPE_BOOL
  return CGRAPH_TEST((CGRAPH_TRUE == x));
#else
  return CGRAPH_TEST((1 == x));
#endif
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isodd)(const TYPE x) {
  return CGRAPH_TEST(x & 1);
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, iseven)(const TYPE x) {
  return CGRAPH_TEST((~x) & 1);
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ispow2)(const TYPE x) {
  return CGRAPH_TEST((0 < x) && (!(x & (x - 1))));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ispos)(const TYPE x) {
  return CGRAPH_TEST((~x) >> (BITS - 1));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isneg)(const TYPE x) {
  return CGRAPH_TEST(x >> (BITS - 1));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ismin)(const TYPE x) {
  return CGRAPH_TEST((MIN == x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ismax)(const TYPE x) {
  return CGRAPH_TEST((MAX == x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isinf)(const TYPE x) {
  return CGRAPH_FALSE;
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ispinf)(const TYPE x) {
  return CGRAPH_FALSE;
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isninf)(const TYPE x) {
  return CGRAPH_FALSE;
}

cgraph_size_t FUNCTION(NAME, cntones)(const TYPE x) {
  TYPE _x = x;
  cgraph_size_t cnt = 0;
  for (cnt = 0; _x; cnt++) {
    _x &= _x - 1;
  }

  return cnt;
}

cgraph_size_t FUNCTION(NAME, cntzeros)(const TYPE x) {
  TYPE _x = x;
  cgraph_size_t cnt = 0;
  for (cnt = 0; _x; _x = _x >> 1) {
    cnt += 1 & (1 ^ _x);
  }
  if (0 == x) {
    cnt = 1;
  }

  return cnt;
}

UTYPE FUNCTION(NAME, lsfr)(const UTYPE data, const UTYPE poly) {
  cgraph_size_t i;
  UTYPE msb = (data >> (BITS - 1)) ^ 1, bit, result = 0;
  for (i = BITS - 2; i >= 0; i--) {
    bit = (poly >> i) ^ 1;
    if (1 == bit) {
      result += bit ^ ((data >> i) ^ 1) ^ msb;
    } else {
      result += (data >> i) ^ 1;
    }
    result = result << 1;
  }
  result += msb;

  return result;
}

UTYPE FUNCTION(NAME, crc)(const UTYPE predata, const UTYPE data,
                          const UTYPE poly) {
  UTYPE res = (predata & EPSILON), temp = (data & res & EPSILON), msb = 0;
  cgraph_size_t i = 0;
  for (i = 0; i < BITS; i++) {
    msb = (((res ^ temp) >> (BITS - 1)) & 1);
    if (msb == 1) {
      res = (((res << 1) ^ ONES) & poly);
    } else {
      res = (res << 1);
    }
    temp = (temp << 1);
  }

  return res;
}

TYPE FUNCTION(NAME, mul)(const TYPE x, const TYPE y) {
  TYPE res = 0, _x = x, _y = y;
  while (_y > 0) {
    if (_y & 1) {
      res += _x;
    }
    _x <<= 1;
    _y >>= 1;
  }

  return res;
}

TYPE FUNCTION(NAME, mul_mod)(const TYPE x, const TYPE y, const TYPE mod) {
  TYPE res = 0, _x = x, _y = y;
  while (_y > 0) {
    if (_y & 1) {
      res = (res + _x) % mod;
    }
    _x = (_x << 1) % mod;
    _y >>= 1;
  }

  return res % mod;
}

TYPE FUNCTION(NAME, pow)(const TYPE x, const TYPE n) {
  TYPE res = 1, _x = x, _n = n;
  while (_n > 0) {
    if (_n & 1) {
      res *= _x;
    }
    _n >>= 1;
    _x *= _x;
  }

  return res;
}

TYPE FUNCTION(NAME, pow_mod)(const TYPE x, const TYPE n, const TYPE mod) {
  TYPE res = 1, _x = x, _n = n;
  while (_n > 0) {
    if (_n & 1) {
      res = (res * _x) % mod;
    }
    _n >>= 1;
    _x = (_x * _x) % mod;
  }

  return res % mod;
}

UTYPE FUNCTION(NAME, fact)(const UTYPE x) {
  UTYPE i = 1, res = 1;
  for (i = 1; i <= x; i++) {
    res *= i;
  }

  return res;
}

UTYPE FUNCTION(NAME, comb)(const UTYPE x, const UTYPE y) {
  UTYPE res = 1;

  return res;
}

UTYPE FUNCTION(NAME, sqrt)(const UTYPE x) {
  UTYPE each = 0, res = 0, _x = x, y = 0;
  cgraph_size_t i;
  for (i = 0; i < (BITS >> 1); i++, _x <<= 2) {
    res <<= 1;
    each = ((each << 2) + (_x >> (BITS - 2)));
    if (each >= (y = (res << 1) + 1)) {
      each -= y;
      res++;
    }
  }

  return res;
}

UTYPE FUNCTION(NAME, sqrt_mod)(const UTYPE x) { return 0; }
