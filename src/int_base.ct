#include "data_base.ct"

cgraph_bool_t FUNCTION(NAME, check)(const TYPE cthis) { return CGRAPH_TRUE; }

/**
 * Fowlerï¼ŒLandon Curt Noll and Phong Vo in 1991) :
 * begin_of_algorithm
 * hash = offset_basis for byte_of_data in data
 * begin
 *   hash = hash ^ byte_of_data
 *   hash = hash * fnv_prime
 * end
 * return hash
 * end_of_algorithm
 *
 * where :
 * 32-bit offset_basis : 2166136261
 * 32-bit fnv_prime    : 16777619 = 2^24 + 2^8 + 0x93
 * 64-bit offset_basis : 14695981039346656037
 * 64-bit fnv_prime    : 1099511628211 = 2^40 + 2^8 + 0xb3
 */
cgraph_size_t FUNCTION(NAME, hash)(const TYPE cthis)
{
#if defined(TYPE_BOOL)
    cgraph_size_t hash = ((cthis == CGRAPH_FALSE) ? 0 : 1);
#elif defined(TYPE_INT)
    cgraph_size_t hash = 2166136261UL;
    char *tmp = (char *)&cthis;
    cgraph_size_t i;
    for (i = 0; i < sizeof(TYPE); i++) {
        hash = (hash ^ tmp[i]) * 16777619UL;
    }
#elif defined(TYPE_INT32)
    cgraph_size_t hash = 0;
    hash = ((cthis >> 16) ^ cthis) * 0x45d9f3b;
    hash = ((hash >> 16) ^ hash) * 0x45d9f3b;
    hash = (hash >> 16) ^ hash;
#else
    cgraph_size_t hash = cthis;
#endif

    return hash;
}

cgraph_int_t FUNCTION(NAME, printf)(const TYPE cthis, const cgraph_char_t *sep)
{
#ifdef TYPE_BOOL
    return fprintf(stdout, "%s",
                   (CGRAPH_FALSE == cthis) ? __cgraph_false__
                                           : __cgraph_true__);
#else
    return __extension__ fprintf(stdout, OUT_FORMAT, cthis);
#endif
}

cgraph_int_t FUNCTION(NAME, fprintf)(FILE *fp, const TYPE cthis,
                                     const cgraph_char_t *sep)
{
#ifdef TYPE_BOOL
    return fprintf(
        fp, "%s", (CGRAPH_FALSE == cthis) ? __cgraph_false__ : __cgraph_true__);
#else
    return __extension__ fprintf(fp, OUT_FORMAT, cthis);
#endif
}

cgraph_int_t FUNCTION(NAME,
                      snprintf)(cgraph_char_t *buffer, const cgraph_size_t size,
                                const TYPE cthis, const cgraph_char_t *sep)
{
#ifdef TYPE_BOOL
    return cgraph_file_snprintf(buffer, size, "%s",
                                (CGRAPH_FALSE == cthis) ? __cgraph_false__
                                                        : __cgraph_true__);
#else
    return cgraph_file_snprintf(buffer, size, OUT_FORMAT, cthis);
#endif
}

TYPE *FUNCTION(NAME, initargs)(TYPE *cthis, const cgraph_size_t size,
                               const TYPE first, ...)
{
    if ((NULL != cthis) && (0 < size)) {
        cgraph_size_t i = 1;
        va_list args;
        va_start(args, first);
        cthis[0] = (TYPE)first;
        for (i = 1; i < size; i++) {
            cthis[i] = (TYPE)va_arg(args, ARG);
        }
        va_end(args);
    }

    return cthis;
}

TYPE FUNCTION(NAME, gcd)(const TYPE x, const TYPE y)
{
    TYPE _x = x, _y = y;
    while (_x != _y) {
        if (_x < _y) {
            SWAP(_x, _y);
        }
        _x -= _y;
    }

    return _x;
}

TYPE FUNCTION(NAME, lcm)(const TYPE x, const TYPE y)
{
    return x / FUNCTION(NAME, gcd)(x, y) * y;
}

CGRAPH_INLINE TYPE FUNCTION(NAME, and)(const TYPE x, const TYPE y)
{
    return CGRAPH_AND(x, y);
}

CGRAPH_INLINE TYPE FUNCTION(NAME, or)(const TYPE x, const TYPE y)
{
    return CGRAPH_OR(x, y);
}

CGRAPH_INLINE TYPE FUNCTION(NAME, not )(const TYPE x) { return CGRAPH_NOT(x); }

CGRAPH_INLINE TYPE FUNCTION(NAME, xor)(const TYPE x, const TYPE y)
{
    return CGRAPH_XOR(x, y);
}

CGRAPH_INLINE TYPE FUNCTION(NAME, xnor)(const TYPE x, const TYPE y)
{
    return CGRAPH_XNOR(x, y);
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, bit)(const UTYPE x,
                                        const cgraph_size_t position)
{
    return (BITS < position) ? CGRAPH_BIT(x, position) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, set)(const UTYPE x,
                                        const cgraph_size_t position)
{
    return (BITS < position) ? CGRAPH_BSET(x, position) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, clr)(const UTYPE x,
                                        const cgraph_size_t position)
{
    return (BITS < position) ? CGRAPH_BCLR(x, position) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, bits)(const UTYPE x,
                                         const cgraph_size_t from,
                                         const cgraph_size_t to)
{
    return (to > from) ? CGRAPH_BITS(x, from, to) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, sets)(const UTYPE x,
                                         const cgraph_size_t from,
                                         const cgraph_size_t to)
{
    return (to > from) ? CGRAPH_BSETS(x, from, to) : 0;
}

CGRAPH_INLINE UTYPE FUNCTION(NAME, clrs)(const UTYPE x,
                                         const cgraph_size_t from,
                                         const cgraph_size_t to)
{
    return (to > from) ? CGRAPH_BCLRS(x, from, to) : 0;
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, iszero)(const TYPE x)
{
    return CGRAPH_TEST((0 == x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ispos)(const TYPE x)
{
    return CGRAPH_TEST((0 < x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isneg)(const TYPE x)
{
    return CGRAPH_TEST((0 > x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ismin)(const TYPE x)
{
    return CGRAPH_TEST((MIN == x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ismax)(const TYPE x)
{
    return CGRAPH_TEST((MAX == x));
}

cgraph_size_t FUNCTION(NAME, ones)(const TYPE x)
{
    TYPE _x = x;
    cgraph_size_t cnt = 0;
    for (cnt = 0; _x; cnt++) {
        _x &= _x - 1;
    }

    return cnt;
}

cgraph_size_t FUNCTION(NAME, zeros)(const TYPE x)
{
    TYPE _x = x;
    cgraph_size_t cnt = 0;
    for (cnt = 0; _x; _x = _x >> 1) {
        cnt += 1 & (1 ^ _x);
    }
    if (0 == x) {
        cnt = 1;
    }

    return cnt;
}

UTYPE FUNCTION(NAME, lsfr)(const UTYPE data, const UTYPE poly)
{
    cgraph_size_t i;
    UTYPE msb = (data >> (BITS - 1)) ^ 1, bit, result = 0;
    for (i = BITS - 2; i >= 0; i--) {
        bit = (poly >> i) ^ 1;
        if (1 == bit) {
            result += bit ^ ((data >> i) ^ 1) ^ msb;
        } else {
            result += (data >> i) ^ 1;
        }
        result = result << 1;
    }
    result += msb;

    return result;
}

UTYPE FUNCTION(NAME, crc)(const UTYPE predata, const UTYPE data,
                          const UTYPE poly)
{
    UTYPE res = (predata & EPSILON), temp = (data & res & EPSILON), msb = 0;
    cgraph_size_t i = 0;
    for (i = 0; i < BITS; i++) {
        msb = (((res ^ temp) >> (BITS - 1)) & 0x01);
        if (msb == 0x01) {
            res = (((res << 1) ^ ONES) & poly);
        } else {
            res = (res << 1);
        }
        temp = (temp << 1);
    }

    return res;
}
