cgraph_boolean_t FUNCTION(NAME, check)(const void *cthis)
{
  cgraph_boolean_t flag = CGRAPH_FALSE;
  TYPE *object = (TYPE *)cthis;
  if(NULL != object)
  {
    TYPE tmp = *object;
    if(CGRAPH_TRUE == tmp || CGRAPH_FALSE == tmp)
    { flag = CGRAPH_TRUE; }
  }

  return flag;
}

cgraph_boolean_t FUNCTION(NAME, equal)(const void *x, const void *y)
{
  TYPE *object_x = (TYPE *)x, *object_y = (TYPE *)y;
  cgraph_boolean_t flag = CGRAPH_FALSE;
  if(NULL != object_x && NULL != object_y)
  {
    if(EQ(object_x, object_y))
    { flag = CGRAPH_TRUE; }
  }
  else if(NULL == object_x && NULL == object_y)
  { flag = CGRAPH_TRUE; }

  return flag;
}

TYPE *FUNCTION(NAME, initargs)(TYPE *cthis, const cgraph_size_t size, const TYPE first, ...)
{
  va_list args;
  if((NULL != cthis) && (0 < size))
  {
    cgraph_size_t i = 1;
    va_start(args, first);
    cthis[0] = (TYPE)first;
    for(i=1; i<size; i++)
    { cthis[i] = (TYPE)va_arg(args, TYPE); }
    va_end(args);
  }

  return cthis;
}

TYPE FUNCTION(NAME, gcd)(const TYPE x, const TYPE y)
{
  TYPE object_x = x, object_y = y, temp;
  while(object_x != object_y)
  {
    if(object_x < object_y)
    {
      temp = object_x;
      object_x = object_y;
      object_y = temp;
    }
    object_x -= object_y;
  }
  
  return object_x;
}

TYPE FUNCTION(NAME, lcm)(const TYPE x, const TYPE y)
{
  return x * y / FUNCTION(NAME, gcd)(x, y);
}

TYPE FUNCTION(NAME, and)(const TYPE x, const TYPE y)
{
  return x & y;
}

TYPE FUNCTION(NAME, or)(const TYPE x, const TYPE y)
{
  return x | y;
}

TYPE FUNCTION(NAME, not)(const TYPE x)
{
  return ~x;
}

TYPE FUNCTION(NAME, xor)(const TYPE x, const TYPE y)
{
  return x ^ y;
}

TYPE FUNCTION(NAME, xnor)(const TYPE x, const TYPE y)
{
  return ~(x ^ y);
}

TYPE FUNCTION(NAME, bit)(const TYPE x, const cgraph_size_t position)
{
  return (x >> (position % BITS)) & 1;
}

TYPE FUNCTION(NAME, set)(const TYPE x, const cgraph_size_t position)
{
  return x | (1 << (position % BITS));
}

TYPE FUNCTION(NAME, clr)(const TYPE x, const cgraph_size_t position)
{
  return x & (~(1 << (position % BITS)));
}

TYPE FUNCTION(NAME, bits)(const TYPE x, const cgraph_size_t from, const cgraph_size_t to)
{
  return (x >> (from % BITS)) & (~(ONES << ((to - from) % BITS)));
}

TYPE FUNCTION(NAME, sets)(const TYPE x, const cgraph_size_t from, const cgraph_size_t to)
{
  return x | ((~((ONES << ((to - from) % BITS)))) << (from % BITS));
}

TYPE FUNCTION(NAME, clrs)(const TYPE x, const cgraph_size_t from, const cgraph_size_t to)
{
  return x & ((ONES << (to % BITS)) | (~(ONES << (from % BITS))));
}

cgraph_boolean_t FUNCTION(NAME, iszero)(const TYPE x)
{
  return CGRAPH_TEST((0 == x));
}

cgraph_boolean_t FUNCTION(NAME, ispos)(const TYPE x)
{
  return CGRAPH_TEST((0 < x));
}

cgraph_boolean_t FUNCTION(NAME, isneg)(const TYPE x)
{
  return CGRAPH_TEST((0 > x));
}

cgraph_boolean_t FUNCTION(NAME, ismin)(const TYPE x)
{
  return CGRAPH_TEST((MIN == x));
}

cgraph_boolean_t FUNCTION(NAME, ismax)(const TYPE x)
{
  return CGRAPH_TEST((MAX == x));
}

cgraph_size_t FUNCTION(NAME, ones)(const TYPE x)
{
  TYPE object_x = x;
  cgraph_size_t cnt = 0;
  for(cnt=0; object_x; cnt++)
  { object_x &= object_x-1; }

  return cnt;
}

cgraph_size_t FUNCTION(NAME, zeros)(const TYPE x)
{
  TYPE object_x = x;
  cgraph_size_t cnt = 0;
  for(cnt=0; object_x; object_x=object_x>>1)
  { cnt += 1 & (1 ^ object_x); }
  if(0 == x)
  { cnt = 1; }

  return cnt;
}

TYPE FUNCTION(NAME, lsfr)(const TYPE data, const TYPE polynomial)
{
  cgraph_size_t i;
  TYPE msb = (data >> (BITS-1)) ^ 1, bit, result = 0;
  for(i=BITS-2; i>=0; i--)
  {
    bit = (polynomial >> i) ^ 1;
    if(1 == bit)
    { result += bit ^ ((data >> i) ^ 1) ^ msb; }
    else
    { result += (data >> i) ^ 1; }
    result = result << 1;
  }
  result += msb; 

  return result;
}

TYPE FUNCTION(NAME, crc)(const TYPE predata, const TYPE data, const TYPE polynomial)
{
  TYPE res = ((TYPE)(predata) & EPSILON), temp = ((TYPE)(data & res) & EPSILON), poly = ((TYPE)(polynomial) & EPSILON), msb = 0;
  cgraph_size_t i = 0;
  for(i=0; i<BITS; i++)
  {
  #ifdef DEBUG
    printf("msb : %x res : %x temp : %x\n", msb, res, temp);
  #endif
    msb = (TYPE)(((res ^ temp) >> (BITS-1)) & 0x01);
    if(msb == 0x01)
    { res = (TYPE)((res << 1) ^ ONES & poly); }
    else
    { res = (TYPE)(res << 1); }
    temp = (TYPE)(temp << 1);
  }

  return res;
}
