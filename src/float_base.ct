#include "data_base.ct"

cgraph_size_t FUNCTION(NAME, hash)(const TYPE cthis) {
  cgraph_size_t hash = 0;
  if (DATA_ISNAN(cthis)) {
    hash = CGRAPH_FLOAT_NAN_HASH;
  } else if (DATA_ISPINF(cthis)) {
    hash = CGRAPH_FLOAT_PINF_HASH;
  } else if (DATA_ISNINF(cthis)) {
    hash = CGRAPH_FLOAT_NINF_HASH;
  } else {
    TYPE ipart = floor(cthis), fpart = cthis - ipart;
    cgraph_size_t hash_ipart = (cgraph_size_t)(ipart),
                  hash_fpart = (cgraph_size_t)(((TYPE)ABS(fpart - EPSILON)) *
                                               EPSILON_LEN);
    hash = (hash_ipart << HASH_OFFSET) ^ hash_fpart;
  }

  return CGRAPH_ABS(hash);
}

cgraph_bool_t FUNCTION(NAME, check)(const TYPE cthis) {
  return CGRAPH_TEST(DATA_TEST(cthis));
}

cgraph_int_t FUNCTION(NAME, printf)(const TYPE cthis) {
  return fprintf(stdout, OUT_FORMAT, cthis);
}

cgraph_int_t FUNCTION(NAME, fprintf)(FILE *fp, const TYPE cthis) {
  return fprintf(fp, OUT_FORMAT, cthis);
}

cgraph_int_t FUNCTION(NAME, snprintf)(cgraph_char_t *buffer,
                                      const cgraph_size_t size,
                                      const TYPE cthis) {
  return cgraph_file_snprintf(buffer, size, OUT_FORMAT, cthis);
}

TYPE *FUNCTION(NAME, initargs)(TYPE *cthis, const cgraph_size_t size,
                               const TYPE first, ...) {
  if ((NULL != cthis) && (0 < size)) {
    va_list args;
    cgraph_size_t i = 1;
    va_start(args, first);
    cthis[0] = (TYPE)first;
    for (i = 1; i < size; i++) {
      cthis[i] = (TYPE)va_arg(args, ARG);
    }
    va_end(args);
  }

  return cthis;
}

TYPE FUNCTION(NAME, zero)(void) { return 0.0; }

TYPE FUNCTION(NAME, one)(void) { return 1.0; }

TYPE FUNCTION(NAME, ones)(void) { return 1.1; }

/**
 * @brief Newton-Raphson method to get square root of a number
 *        x(n+1) = 0.5 * (x(n) + a / x(n))
 *        where x(0) = 0.5 * x
 */
TYPE FUNCTION(NAME, sqrt)(const TYPE x) {
  TYPE _x, _y = 0.5 * x;
  do {
    _x = _y;
    _y = 0.5 * (_x + x / _x);
  } while (NE(_x, _y));

  return _y;
}

/**
 * @brief Newton-Raphson method to get cube root of a number
 *        x(n+1) = (2 * x(n) + a / (x(n)^2)) / 3
 *        where x(0) = x / 3.0;
 */
TYPE FUNCTION(NAME, cube)(const TYPE x) {
  TYPE _x, _y = x / 3.0;
  do {
    _x = _y;
    _y = (2.0 * _x + x / _x / _x) / 3.0;
  } while (NE(_x, _y));

  return _y;
}

TYPE FUNCTION(NAME, exp)(const TYPE x) {
  TYPE res = 0.0, each = 1.0;
  cgraph_int_t i = 1;
  for (i = 1; GR(ABS(each), 0.0); i++) {
    res += each;
    each = x / i * each;
  }

  return res;
}

TYPE FUNCTION(NAME, pi)(void) {
  TYPE res = 0.0, num1 = 3.2, num2 = -4.0 / 239, each = 1.0;
  cgraph_int_t i = 1;
  for (i = 1; GR(ABS(each), 0.0); i += 2) {
    each = (num1 + num2) / i;
    res += each;
    num1 /= -25;
    num2 /= -57121;
  }

  return res;
}

CGRAPH_INLINE cgraph_int_t FUNCTION(NAME, signbit)(const TYPE cthis) {
#if CGRAPH_PLAT_ENDIAN == 0
  return ((cgraph_int8_t *)&cthis)[sizeof(TYPE) - 1] >> 7;
#else
  return ((cgraph_int8_t *)&cthis)[0] >> 7;
#endif
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isnan)(const TYPE x) {
  return CGRAPH_TEST(DATA_ISNAN(x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isinf)(const TYPE x) {
  return CGRAPH_TEST(DATA_ISINF(x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ispinf)(const TYPE x) {
  return CGRAPH_TEST(DATA_ISPINF(x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isninf)(const TYPE x) {
  return CGRAPH_TEST(DATA_ISNINF(x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, iszero)(const TYPE x) {
  return CGRAPH_TEST(EQ(x, 0.0));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ispos)(const TYPE x) {
  return CGRAPH_TEST(DATA_ISPOS(x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, isneg)(const TYPE x) {
  return CGRAPH_TEST(DATA_ISNEG(x));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ismin)(const TYPE x) {
  return CGRAPH_TEST(EQ(x, MIN));
}

CGRAPH_INLINE cgraph_bool_t FUNCTION(NAME, ismax)(const TYPE x) {
  return CGRAPH_TEST(EQ(x, MAX));
}

CGRAPH_INLINE TYPE FUNCTION(NAME, int)(const TYPE x, const TYPE y) {
#if defined(TYPE_FLOAT32) && (CGRAPH_STDC_VERSION >= 199901L)
  TYPE res = 0.0;
  modff(x / y, &res);
#elif defined(TYPE_FLOAT128) && defined(CGRAPH_WITH_FLOAT128)
  TYPE res = 0.0;
  modfl(x / y, &res);
#else
  ARG res = 0.0;
  modf(x / y, &res);
#endif

  return res;
}

TYPE FUNCTION(NAME, eqt_binary_search)(const TYPE start, const TYPE end,
                                       FUNCPTR(NAME, pfunc1) func) {
  TYPE _start = start, _end = end, _middle;
  TYPE _start_res = func(start), _end_res = func(end), _middle_res;
  if (FUNCTION(NAME, cmp_signbit)(_start_res, _end_res)) {
    return CGRAPH_MIN(_start, _end);
  }
  do {
    _middle = 0.5 * (_start + _end);
    _middle_res = func(_middle);
    if (!FUNCTION(NAME, cmp_signbit)(_start_res, _end_res)) {
      _end = _middle;
      _end_res = _middle_res;
    } else {
      _start = _middle;
      _start_res = _middle_res;
    }
  } while (NE(_start, _end));

  return _middle;
}

TYPE FUNCTION(NAME, eqt_secant_method)(const TYPE start, const TYPE end,
                                       FUNCPTR(NAME, pfunc1) func) {
  TYPE _x0 = start, _x1 = end, _x2;
  TYPE _x0_res = func(start), _x1_res = func(end), _x2_res;
  do {
    _x2 = _x1 - (_x1 - _x0) / (_x1_res - _x0_res) * _x1_res;
    _x2_res = func(_x2);
    _x0 = _x1;
    _x0_res = _x1_res;
    _x1 = _x2;
    _x1 = _x2_res;
  } while (NE(_x2_res, 0.0));

  return _x2;
}

TYPE FUNCTION(NAME, eqt_inverse_interpolation)(const TYPE start, const TYPE end,
                                               FUNCPTR(NAME, pfunc1) func) {
  TYPE _start = start, _end = end, _middle;
  TYPE _start_res = func(start), _end_res = func(end), _middle_res;
  if (FUNCTION(NAME, cmp_signbit)(_start_res, _end_res)) {
    return CGRAPH_MIN(_start, _end);
  }
  do {
    _middle = (_start * _end_res - _end * _start_res) / (_end_res - _start_res);
    _middle_res = func(_middle);
    if (!FUNCTION(NAME, cmp_signbit)(_start_res, _end_res)) {
      _end = _middle;
      _end_res = _middle_res;
    } else {
      _start = _middle;
      _start_res = _middle_res;
    }
  } while (NE(_start, _end));

  return _middle;
}

/**
 * @brief
 *   x = f(x)
 */
TYPE FUNCTION(NAME, eqt_fixed_point)(const TYPE x, FUNCPTR(NAME, pfunc1) func) {
  TYPE _x, _y = x;
  do {
    _x = _y;
    _y = func(_x);
  } while (NE(_x, _y));

  return _y;
}

TYPE FUNCTION(NAME, eqt_fixed_point_lambda)(const TYPE x, const TYPE lambda,
                                            FUNCPTR(NAME, pfunc1) func) {
  TYPE _x, _y = x;
  do {
    _x = _y;
    _y = _x - lambda * func(_x);
  } while (NE(_x, _y));

  return _y;
}

/**
 * @brief
 *
 */
TYPE FUNCTION(NAME, diff)(const TYPE x, const TYPE step,
                          FUNCPTR(NAME, pfunc1) func) {
  return (func(x + step) - func(x)) / x;
}

/**
 * @brief s-4 Runge-Kutta
 *        dy = f(x, y)
 *        delta = x(n+1) - x(n)
 *        y(n+1) = y(n) + delta/6.0 * (k1 + 2k2+ 2k3 + k4)
 *        where :
 *        k1 = f(x(n), y(n))
 *        k2 = f(x(n)+delta/2, y(n)+delta/2*k1)
 *        k3 = f(x(n)+delta/2, y(n)+delta/2*k2)
 *        k4 = f(x(n)+delta, y(n)+delta*k3)
 */
TYPE FUNCTION(NAME, diff_runge_kutta_s4)(const TYPE x_start, const TYPE x_end,
                                         const TYPE y_start, const TYPE step,
                                         FUNCPTR(NAME, pfunc2) func) {
  TYPE _step_2 = 0.5 * step, _step_6 = step / 6.0, _step_3 = step / 3.0;
  TYPE _x = x_start, _y = y_start, k1 = 0.0, k2 = 0.0, k3 = 0.0, k4 = 0.0;
  do {
    k1 = func(_x, _y);
    _x += _step_2;
    k2 = func(_x, _y + _step_2 * k1);
    k3 = func(_x, _y + _step_2 * k2);
    _x += _step_2;
    k4 = func(_x, _y + _step_2 * k3);
    _y += (_step_6 * (k1 + k4) + _step_3 * (k2 + k3));
  } while (LS(_x, x_end));

  return _y;
}

TYPE FUNCTION(NAME, diff_kutta_s4)(const TYPE x_start, const TYPE x_end,
                                   const TYPE y_start, const TYPE step,
                                   FUNCPTR(NAME, pfunc2) func) {
  TYPE _step_3 = step / 3.0, _step_8 = 0.125 * step, _step3_8 = 0.375 * step;
  TYPE _x = x_start, _y = y_start, k1 = 0.0, k2 = 0.0, k3 = 0.0, k4 = 0.0;
  do {
    k1 = func(_x, _y);
    _x += _step_3;
    k2 = func(_x, _y + _step_3 * k1);
    _x += _step_3;
    k3 = func(_x, _y - _step_3 * k1 + step * k2);
    _x += _step_3;
    k4 = func(_x, _y + step * (k1 - k2 + k3));
    _y += (_step_8 * (k1 + k4) + _step3_8 * (k2 + k3));
  } while (LS(_x, x_end));

  return _y;
}

/**
 * @brief
 *
 */
TYPE FUNCTION(NAME, intg)(const TYPE x, const TYPE step,
                          FUNCPTR(NAME, pfunc1) func) {
  return 0.5 * x * (func(x) + func(x + step));
}

/**
 * @brief trapezoidal intg operation
 *        delta = x(n+1) - x(n)
 *        df = 0.5 * delta * (f(x(n)) + f(x(n+1)))
 */
TYPE FUNCTION(NAME, intg_range_trapezoidal)(const TYPE start, const TYPE end,
                                            const TYPE step,
                                            FUNCPTR(NAME, pfunc1) func) {
  TYPE _step = 0.5 * step, _res = 0.0;
  if (EQ(start, end)) {
    _res = 0.0;
  } else {
    TYPE _start = start, _end = end;
    if (GR(start, end)) {
      _start = end;
      _end = start;
    }
    do {
      _res += _step * (func(_start) + func(_start + step));
      _start += step;
    } while (LS(_start, _end));
    if (GR(start, end)) {
      _res = -1.0 * _res;
    }
  }

  return _res;
}

/**
 * @brief simpson intg operation
 *        delta = x(n+1) - x(n)
 *        df = (delta / 6.0 * (
 *             f(x(n)) +
 *             4.0 * f(x(n) + 0.5 * delta) +
 *             f(x(n+1))
 *             )
 */
TYPE FUNCTION(NAME, intg_range_simpson)(const TYPE start, const TYPE end,
                                        const TYPE step,
                                        FUNCPTR(NAME, pfunc1) func) {
  TYPE _step = step / 6.0, _res = 0.0;
  if (EQ(start, end)) {
    _res = 0.0;
  } else {
    TYPE _start = start, _end = end;
    if (GR(start, end)) {
      _start = end;
      _end = start;
    }
    do {
      _res += _step * (func(_start) + 4.0 * func(_start + 0.5 * step) +
                       func(_start + step));
      _start += step;
    } while (LS(_start, _end));
    if (GR(start, end)) {
      _res = -1.0 * _res;
    }
  }

  return _res;
}

/**
 * @brief 3/8 rule simpson intg operation
 *        delta = x(n+1) - x(n)
 *        df = 0.125 * delta * (
 *             f(x(n)) +
 *             3.0 * (f(x(n) + delta / 3.0) + f(x(n) + delta * 2.0 / 3.0)) +
 *             f(x(n+1))
 *             )
 */
TYPE FUNCTION(NAME, intg_range_simpson38)(const TYPE start, const TYPE end,
                                          const TYPE step,
                                          FUNCPTR(NAME, pfunc1) func) {
  TYPE _step = 0.125 * step, _res = 0.0;
  if (EQ(start, end)) {
    _res = 0.0;
  } else {
    TYPE _start = start, _end = end;
    if (GR(start, end)) {
      _start = end;
      _end = start;
    }
    do {
      _res +=
          _step *
          (func(_start) +
           3.0 * (func(_start + step / 3.0) + func(_start + 2.0 / 3.0 * step)) +
           func(_start + step));
      _start += step;
    } while (LS(_start, _end));
    if (GR(start, end)) {
      _res = -1.0 * _res;
    }
  }

  return _res;
}

/**
 * @brief cotes intg operation
 *        delta = x(n+1) - x(n)
 *        df = delta / 90.0 * (
 *             7.0 * (f(x(n)) + f(x(n+1))) +
 *             32.0 * (f(x(n) + delta * 0.25) + f(x(n) + delta * 0.75)) +
 *             12.0 * f(x(n) + delta * 0.5))
 *             )
 */
TYPE FUNCTION(NAME, intg_range_cotes)(const TYPE start, const TYPE end,
                                      const TYPE step,
                                      FUNCPTR(NAME, pfunc1) func) {
  TYPE _step = step / 90.0, _res = 0.0;
  if (EQ(start, end)) {
    _res = 0.0;
  } else {
    cgraph_size_t i = 0;
    TYPE _start = start, _end = end;
    if (GR(start, end)) {
      _start = end;
      _end = start;
    }
    for (i = 0; LS(_start, _end); i++) {
      _res +=
          _step *
          (7.0 * (func(_start) + func(_start + step)) +
           32.0 * (func(_start + 0.25 * step) + func(_start + 0.75 * step)) +
           12.0 * func(_start + 0.5 * step));
      _start += step;
    }
    if (GR(start, end)) {
      _res = -1.0 * _res;
    }
  }

  return _res;
}
