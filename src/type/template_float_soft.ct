/**
 * software-defined float point numbers
 * IEEE Standard 754 for Binary Floating-Point Arithmetic
 * Refered from
 * https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
 * stored in memory:
 * msb                                    lsb
 * [sign bit] [exponent bits] [fraction bits]
 * x = frac * 2 ^ (exp - bias)
 * |          | sig(ub) | exp(ub) | bias(ud) | frac(ub) |
 * |   :-:    |   :-:   |   :-:   |   :-:    |   :-:    |
 * | float8   |    1    |     3   |       3  |      4   |
 * | float16  |    1    |     7   |      63  |      8   |
 * | float32  |    1    |     8   |     127  |     23   |
 * | float64  |    1    |    11   |    1023  |     52   |
 * | float80  |    1    |    15   |   16383  |     63   |
 * | float128 |    1    |    15   |   16383  |    112   |
 * where
 *   1) ub is unsigned bit
 *   2) ud is unsigned decimal number
 */

TYPE FUNCTION(NAME, tofrac_s)(const cgraph_int_t x) {
  cgraph_size_t bits = x;

  return x;
}

TYPE FUNCTION(NAME, setfrac_s)(const TYPE x, const cgraph_int_t bit) {
  return (TYPE)(x | (((1U << bit) & FRAC_MASK) << FRAC_OFFSET));
}

TYPE FUNCTION(NAME, setfracs_s)(const TYPE x, const cgraph_int_t y) {
  return FLOAT_SOFT_FRAC_SET(x, y);
}

TYPE FUNCTION(NAME, clrfrac_s)(const TYPE x, const cgraph_int_t bit) {
  return (TYPE)(x & ((~((1U << bit) & FRAC_MASK)) << FRAC_OFFSET));
}

TYPE FUNCTION(NAME, clrfracs_s)(const TYPE x) { return FLOAT_SOFT_FRAC_CLR(x); }

TYPE FUNCTION(NAME, shlfrac_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_FRAC_CLR(x);
  res += FLOAT_SOFT_TOFRAC(FLOAT_SOFT_FRAC(x) << y);

  return res;
}

TYPE FUNCTION(NAME, shrfrac_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_FRAC_CLR(x);
  res += FLOAT_SOFT_TOFRAC(FLOAT_SOFT_FRAC(x) >> y);

  return res;
}

TYPE FUNCTION(NAME, addfrac_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_FRAC_CLR(x);
  res += FLOAT_SOFT_TOFRAC(FLOAT_SOFT_FRAC(x) + y);

  return res;
}

TYPE FUNCTION(NAME, subfrac_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_FRAC_CLR(x);
  res += FLOAT_SOFT_TOFRAC(FLOAT_SOFT_FRAC(x) - y);

  return res;
}

TYPE FUNCTION(NAME, mulfrac_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_FRAC_CLR(x);
  res += FLOAT_SOFT_TOFRAC(FLOAT_SOFT_FRAC(x) * y);

  return res;
}

TYPE FUNCTION(NAME, divfrac_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_FRAC_CLR(x);
  res += FLOAT_SOFT_TOFRAC(FLOAT_SOFT_FRAC(x) / y);

  return res;
}

TYPE FUNCTION(NAME, setexp_s)(const TYPE x, const cgraph_int_t bit) {
  return (TYPE)(x | (((1U << bit) & EXP_MASK) << EXP_OFFSET));
}

TYPE FUNCTION(NAME, setexps_s)(const TYPE x, const cgraph_int_t y) {
  return FLOAT_SOFT_EXP_SET(x, y);
}

TYPE FUNCTION(NAME, clrexp_s)(const TYPE x, const cgraph_int_t bit) {
  return (TYPE)(x & ((~((1U << bit) & EXP_MASK)) << EXP_OFFSET));
}

TYPE FUNCTION(NAME, clrexps_s)(const TYPE x) { return FLOAT_SOFT_EXP_CLR(x); }

TYPE FUNCTION(NAME, shlexp_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_EXP_CLR(x);
  res += FLOAT_SOFT_TOEXP(FLOAT_SOFT_EXP(x) << y);

  return res;
}

TYPE FUNCTION(NAME, shrexp_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FLOAT_SOFT_EXP_CLR(x);
  res += FLOAT_SOFT_TOEXP(FLOAT_SOFT_EXP(x) >> y);

  return res;
}

TYPE FUNCTION(NAME, addexp_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FUNCTION(NAME, clrexps_s)(x);
  res += FLOAT_SOFT_TOEXP(FLOAT_SOFT_EXP(x) + y);

  return res;
}

TYPE FUNCTION(NAME, subexp_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FUNCTION(NAME, clrexps_s)(x);
  res += FLOAT_SOFT_TOEXP(FLOAT_SOFT_EXP(x) - y);

  return res;
}

TYPE FUNCTION(NAME, mulexp_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FUNCTION(NAME, clrexps_s)(x);
  res += FLOAT_SOFT_TOEXP(FLOAT_SOFT_EXP(x) * y);

  return res;
}

TYPE FUNCTION(NAME, divexp_s)(const TYPE x, const cgraph_int_t y) {
  TYPE res = FUNCTION(NAME, clrexps_s)(x);
  res += FLOAT_SOFT_TOEXP(FLOAT_SOFT_EXP(x) / y);

  return res;
}

TYPE FUNCTION(NAME, initf32)(const cgraph_float32_t x) {
  TYPE res;

  return res;
}

cgraph_float32_t FUNCTION(NAME, tof32)(const TYPE x) {
  cgraph_float32_t res;

  return res;
}

TYPE FUNCTION(NAME, initf64)(const cgraph_float64_t x) {
  TYPE res;

  return res;
}

cgraph_float64_t FUNCTION(NAME, tof64)(const TYPE x) {
  cgraph_float64_t res;

  return res;
}

TYPE FUNCTION(NAME, format_s)(const TYPE x) {
  TYPE res;
  DATA_TYPE exp = FLOAT_SOFT_EXP(x), frac = FLOAT_SOFT_FRAC_FMT(x);
  while (0 == (frac & (0x01U << (FRAC_OFFSET - 1)))) {
    frac >>= 1;
    exp += 1;
  }
  res = FLOAT_SOFT_TOFRAC(frac);
  res += FLOAT_SOFT_TOEXP(exp);

  return res;
}

TYPE FUNCTION(NAME, one_s)(void) { return EXP_MASK << EXP_OFFSET; }

TYPE FUNCTION(NAME, zero_s)(void) { return 0; }

TYPE FUNCTION(NAME, opp_s)(const TYPE x) {
  return (TYPE)(x ^ (SIG_MASK << SIG_OFFSET));
}

TYPE FUNCTION(NAME, fabs_s)(const TYPE x) {
  return (x & (~(SIG_MASK << SIG_OFFSET)));
}

TYPE FUNCTION(NAME, inv_s)(const TYPE x) {
  TYPE res;

  return res;
}

cgraph_bool_t FUNCTION(NAME, eq_s)(const TYPE x, const TYPE y) {
  return FUNCTION(NAME, fabs_s)(FUNCTION(NAME, sub_s)(x, y)) < EPSILON;
}

cgraph_bool_t FUNCTION(NAME, ne_s)(const TYPE x, const TYPE y) {
  return CGRAPH_NTEST(FUNCTION(NAME, eq_s)(x, y));
}

cgraph_bool_t FUNCTION(NAME, gr_s)(const TYPE x, const TYPE y) {
  cgraph_bool_t flag = CGRAPH_FALSE;
  DATA_TYPE x_sig = FLOAT_SOFT_SIG(x), x_exp = FLOAT_SOFT_EXP(x),
            x_frac = FLOAT_SOFT_FRAC(x);
  DATA_TYPE y_sig = FLOAT_SOFT_SIG(y), y_exp = FLOAT_SOFT_EXP(y),
            y_frac = FLOAT_SOFT_FRAC(y);
  if ((x_exp > y_exp) || ((x_exp == y_exp) && (x_frac > y_frac))) {
    flag = CGRAPH_TRUE;
  }
  if ((x_sig > y_sig) || ((x_sig == y_sig) && x_sig)) {
    flag = CGRAPH_NTEST(flag);
  }

  return flag;
}

cgraph_bool_t FUNCTION(NAME, ge_s)(const TYPE x, const TYPE y) {
  return CGRAPH_NTEST(FUNCTION(NAME, gr_s)(y, x));
}

cgraph_bool_t FUNCTION(NAME, ls_s)(const TYPE x, const TYPE y) {
  return FUNCTION(NAME, gr_s)(y, x);
}

cgraph_bool_t FUNCTION(NAME, le_s)(const TYPE x, const TYPE y) {
  return CGRAPH_NTEST(FUNCTION(NAME, gr)(x, y));
}

cgraph_bool_t FUNCTION(NAME, isone_s)(const TYPE x) {
  DATA_TYPE exp = FLOAT_SOFT_EXP(x), frac = FLOAT_SOFT_FRAC_FMT(x);

  return (EXP_MASK == exp) && (0 == frac);
}

cgraph_bool_t FUNCTION(NAME, iszero_s)(const TYPE x) {
  DATA_TYPE exp = FLOAT_SOFT_EXP(x), frac = FLOAT_SOFT_FRAC_FMT(x);

  return (0 == exp) && (0 == frac);
}

cgraph_bool_t FUNCTION(NAME, test_s)(const TYPE x) {
  return FUNCTION(NAME, ls_s)(x, MAX) && FUNCTION(NAME, gr_s)(x, MIN);
}

cgraph_bool_t FUNCTION(NAME, isnan_s)(const TYPE x) {
  DATA_TYPE exp = FLOAT_SOFT_EXP(x), frac = FLOAT_SOFT_FRAC_FMT(x);

  return (EXP_MASK == exp) && frac;
}

cgraph_bool_t FUNCTION(NAME, ispinf_s)(const TYPE x) { return PINF == x; }

cgraph_bool_t FUNCTION(NAME, isninf_s)(const TYPE x) { return NINF == x; }

cgraph_bool_t FUNCTION(NAME, isinf_s)(const TYPE x) {
  return (PINF == x) || (NINF == x);
}

TYPE FUNCTION(NAME, add_s)(const TYPE x, const TYPE y) {
  DATA_TYPE x_sig = FLOAT_SOFT_SIG(x), x_exp = FLOAT_SOFT_EXP(x),
            x_frac = FLOAT_SOFT_FRAC(x);
  DATA_TYPE y_sig = FLOAT_SOFT_SIG(y), y_exp = FLOAT_SOFT_EXP(y),
            y_frac = FLOAT_SOFT_FRAC(y);
  TYPE res;
  while (x_exp != y_exp) {
    if (x_exp > y_exp) {
      y_frac >>= 1;
      y_exp += 1;
    } else {
      x_frac <<= 1;
      x_exp -= 1;
    }
  }
  res = FLOAT_SOFT_TOFRAC(x_frac + y_frac);
  res += FLOAT_SOFT_TOEXP(x_exp);

  return res;
}

TYPE FUNCTION(NAME, sub_s)(const TYPE x, const TYPE y) {
  return FUNCTION(NAME, add_s)(x, FUNCTION(NAME, opp_s)(y));
}

TYPE FUNCTION(NAME, mul_s)(const TYPE x, const TYPE y) {
  DATA_TYPE x_sig = FLOAT_SOFT_SIG(x), x_exp = FLOAT_SOFT_EXP(x),
            x_frac = FLOAT_SOFT_FRAC(x);
  DATA_TYPE y_sig = FLOAT_SOFT_SIG(y), y_exp = FLOAT_SOFT_EXP(y),
            y_frac = FLOAT_SOFT_FRAC(y);
  TYPE res = FLOAT_SOFT_TOEXP(x_exp + y_exp);
  res += FLOAT_SOFT_TOFRAC(x_frac * y_frac);
  res = (x_sig == y_sig) ? FUNCTION(NAME, fabs_s)(res)
                         : FUNCTION(NAME, opp_s)(res);

  return res;
}

TYPE FUNCTION(NAME, div_s)(const TYPE x, const TYPE y) {
  DATA_TYPE x_sig = FLOAT_SOFT_SIG(x), x_exp = FLOAT_SOFT_EXP(x),
            x_frac = FLOAT_SOFT_FRAC(x);
  DATA_TYPE y_sig = FLOAT_SOFT_SIG(y), y_exp = FLOAT_SOFT_EXP(y),
            y_frac = FLOAT_SOFT_FRAC(y);
  TYPE res = FLOAT_SOFT_TOEXP(x_exp - y_exp);
  res += FLOAT_SOFT_TOFRAC(x_frac / y_frac);
  res = (x_sig == y_sig) ? FUNCTION(NAME, fabs_s)(res)
                         : FUNCTION(NAME, opp_s)(res);

  return res;
}

cgraph_int_t FUNCTION(NAME, signbit_s)(const TYPE x) {
  return (x >> SIG_OFFSET) & SIG_MASK;
}

cgraph_int_t FUNCTION(NAME, frexp_s)(const TYPE x, cgraph_int_t *y) {
  if (NULL != y) {
    *y = FLOAT_SOFT_EXP(x);
  }

  return FLOAT_SOFT_FRAC(x);
}

TYPE FUNCTION(NAME, int_s)(const TYPE x, const TYPE y) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, mod_s)(const TYPE x, const TYPE y) {
  TYPE res = 0;

  return res;
}

cgraph_int_t FUNCTION(NAME, floor_s)(const TYPE x) {
  cgraph_int_t res = 0;

  return res;
}

cgraph_int_t FUNCTION(NAME, ceil_s)(const TYPE x) {
  cgraph_int_t res = 0;

  return res;
}

TYPE FUNCTION(NAME, fmod_s)(const TYPE x, const TYPE y) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, modf_s)(const TYPE x, const TYPE *y) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, abs_s)(const TYPE x) {
  return (x & (~(SIG_MASK << SIG_OFFSET)));
}

TYPE FUNCTION(NAME, log_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, log2_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, log10_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, exp_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, sqrt_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, pow_s)(const TYPE x, const TYPE y) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, sin_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, cos_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, tan_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, cot_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, sec_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, csc_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, sinh_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, cosh_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, tanh_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, coth_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, sech_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, csch_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, asin_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, acos_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

TYPE FUNCTION(NAME, atan_s)(const TYPE x) {
  TYPE res = 0;

  return res;
}

#include "template_float.ct"
